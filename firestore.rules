rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function hasOnlyKeys(allowedKeys) {
      return request.resource.data.keys().hasOnly(allowedKeys);
    }

    function isNumber(value) {
      return value is int || value is float;
    }

    // --- Public reads (demo scale) ---
    match /motorcycles/{id} {
      allow read: if true;
      allow write: if false;
    }

    match /listings/{listingId} {
      allow read: if true;

      // Create listing: seller-only, immutable core fields, and bid fields must start clean.
      allow create: if isSignedIn()
        && request.resource.data.sellerId == request.auth.uid
        && request.resource.data.isClosed == false
        && request.resource.data.hasBid == false
        && isNumber(request.resource.data.startingBid)
        && request.resource.data.closingTimeMillis is int
        && isNumber(request.resource.data.buyOutPrice)
        && request.resource.data.dateCreatedMillis is int
        // Prefer `currentBid` absent on create; if present it must be null.
        && (!('currentBid' in request.resource.data) || request.resource.data.currentBid == null)
        && (!('currentBidderId' in request.resource.data) || request.resource.data.currentBidderId == null)
        && (!('closedAtMillis' in request.resource.data) || request.resource.data.closedAtMillis == null)
        && (!('closingBid' in request.resource.data) || request.resource.data.closingBid == null)
        && (!('winnerUserId' in request.resource.data) || request.resource.data.winnerUserId == null);

      // Seller can update/close listing. Keep this permissive but field-constrained.
      allow update: if isOwner(resource.data.sellerId)
        && (
          // Seller closing path.
          (
            request.resource.data.isClosed == true
            // Treat missing isClosed as "not closed" for older docs.
            && resource.data.isClosed != true
            && request.resource.data.closedAtMillis is int
            && (
              (
                // Closing with bids: must set closingBid + winnerUserId.
                resource.data.hasBid == true
                && request.writeFields.hasOnly(['isClosed', 'closedAtMillis', 'closingBid', 'winnerUserId'])
                && isNumber(resource.data.currentBid)
                && isNumber(request.resource.data.closingBid)
                && request.resource.data.closingBid == resource.data.currentBid
                && request.resource.data.winnerUserId is string
                && request.resource.data.winnerUserId == resource.data.currentBidderId
              )
              ||
              (
                // Closing with no bids.
                resource.data.hasBid != true
                && request.writeFields.hasOnly(['isClosed', 'closedAtMillis'])
              )
            )
          )
          ||
          // Seller non-bid edits (notes only) while open.
          (
            request.resource.data.isClosed == resource.data.isClosed
            && request.resource.data.hasBid == resource.data.hasBid
            && request.resource.data.currentBid == resource.data.currentBid
            && request.resource.data.currentBidderId == resource.data.currentBidderId
            && request.resource.data.closingTimeMillis == resource.data.closingTimeMillis
            && request.resource.data.startingBid == resource.data.startingBid
            && request.resource.data.buyOutPrice == resource.data.buyOutPrice
            && request.resource.data.winnerUserId == resource.data.winnerUserId
            && request.resource.data.bikeId == resource.data.bikeId
            && request.resource.data.brandKey == resource.data.brandKey
            && request.resource.data.brandLabel == resource.data.brandLabel
            && request.resource.data.category == resource.data.category
            && request.resource.data.displacementBucket == resource.data.displacementBucket
            && request.resource.data.bikeTitle == resource.data.bikeTitle
          )
        );

      // Buyout: non-owner can close instantly at buyOutPrice and become winner.
      allow update: if isSignedIn()
        && request.auth.uid != resource.data.sellerId
        && resource.data.isClosed != true
        && request.time.toMillis() < resource.data.closingTimeMillis
        && request.writeFields.hasOnly([
          'isClosed',
          'closedAtMillis',
          'hasBid',
          'currentBid',
          'currentBidderId',
          'closingBid',
          'winnerUserId'
        ])
        && request.resource.data.isClosed == true
        && request.resource.data.closedAtMillis is int
        && request.resource.data.hasBid == true
        && isNumber(request.resource.data.currentBid)
        && isNumber(request.resource.data.closingBid)
        && request.resource.data.currentBidderId == request.auth.uid
        && request.resource.data.winnerUserId == request.auth.uid
        && request.resource.data.currentBid == request.resource.data.buyOutPrice
        && request.resource.data.closingBid == request.resource.data.buyOutPrice;

      // Auto-close after expiry: allow any signed-in user to close, but only
      // at/after `closingTimeMillis`, with deterministic closedAtMillis.
      allow update: if isSignedIn()
        && resource.data.isClosed != true
        && request.time.toMillis() >= resource.data.closingTimeMillis
        && request.resource.data.isClosed == true
        && request.resource.data.closedAtMillis == resource.data.closingTimeMillis
        && (
          (
            // Expired with bids: must write closingBid + winnerUserId.
            resource.data.hasBid == true
            && request.writeFields.hasOnly(['isClosed', 'closedAtMillis', 'closingBid', 'winnerUserId'])
            && isNumber(resource.data.currentBid)
            && isNumber(request.resource.data.closingBid)
            && request.resource.data.closingBid == resource.data.currentBid
            && request.resource.data.winnerUserId is string
            && request.resource.data.winnerUserId == resource.data.currentBidderId
          )
          ||
          (
            // Expired with no bids.
            resource.data.hasBid != true
            && request.writeFields.hasOnly(['isClosed', 'closedAtMillis'])
          )
        );

      // Bidding users can ONLY bump currentBid + hasBid.
      allow update: if isSignedIn()
        && request.auth.uid != resource.data.sellerId
        // Treat missing isClosed as "not closed" for older docs.
        && resource.data.isClosed != true
        // Note: we intentionally do NOT enforce `closingTimeMillis` using
        // `request.time` here, because client-created listings can have clock
        // skew vs server time, which would surface as a confusing
        // PERMISSION_DENIED during bidding. The app enforces the cutoff in the
        // repository/ViewModel for demo correctness.
        // Only allow bidders to change the bid state fields.
        // Use diff().affectedKeys() so this works consistently for update() and
        // set(..., merge: true) style writes.
        // && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
        //   'hasBid',
        //   'currentBid',
        //   'currentBidderId'
        // ])
        // && request.resource.data.hasBid == true
        // && isNumber(request.resource.data.currentBid)
        // && request.resource.data.currentBid > 0
        // && request.resource.data.currentBidderId == request.auth.uid
        // && (
        //   // First bid
        //   (
        //     (resource.data.currentBid == null || !isNumber(resource.data.currentBid))
        //     // Don't compare against `startingBid` in rules to avoid int/float
        //     // type-mismatch surprises (the app enforces the minimum).
        //   )
        //   ||
        //   // Subsequent bids
        //   (
        //     isNumber(resource.data.currentBid)
        //     && request.resource.data.currentBid > resource.data.currentBid
        //   )
        // );

      allow delete: if false;
    }

    match /bids/{bidId} {
      allow read: if true;

      // Allow authenticated bid creation.
      allow create: if isSignedIn()
        && request.resource.data.bidderId == request.auth.uid
        && request.resource.data.listingId is string
        && isNumber(request.resource.data.amount)
        && request.resource.data.amount > 0
        && request.resource.data.dateCreatedMillis is int
        && hasOnlyKeys(['listingId', 'bidderId', 'amount', 'dateCreatedMillis']);

      allow update, delete: if false;
    }

    match /comments/{commentId} {
      allow read: if true;
      allow create: if isSignedIn();

      // Voting: one vote doc per user per comment.
      match /votes/{userId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId)
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.direction in ['up', 'down']
          && request.resource.data.dateCreatedMillis is int
          && hasOnlyKeys(['userId', 'direction', 'dateCreatedMillis']);

        // Immutable vote docs.
        allow update, delete: if false;
      }

      // Only allow authenticated users to increment vote counters by +1, and
      // only if they have not already created a vote doc for this comment.
      allow update: if isSignedIn()
        && !exists(/databases/$(database)/documents/comments/$(commentId)/votes/$(request.auth.uid))
        && (
          (
            request.writeFields.hasOnly(['upvoteCount'])
            && request.resource.data.upvoteCount is int
            && resource.data.upvoteCount is int
            && request.resource.data.upvoteCount == resource.data.upvoteCount + 1
          )
          ||
          (
            request.writeFields.hasOnly(['downvoteCount'])
            && request.resource.data.downvoteCount is int
            && resource.data.downvoteCount is int
            && request.resource.data.downvoteCount == resource.data.downvoteCount + 1
          )
        );
      allow delete: if false;
    }

    match /users/{userId} {
      allow read: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if false;
    }
  }
}